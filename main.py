import vk_api
from vk_api.bot_longpoll import VkBotLongPoll, VkBotEventType
from vk_api.keyboard import VkKeyboard, VkKeyboardColor
import random
import datetime
from data import db_session
from data.user import User
from data.modificators import Modificators

TOKEN = 'cccf1a05dec0e26b5388dbaf2190362a2a4c2692f7aeebe98b36b2c19031ad1980136723e8bbea17879ed'
BOT_START_TIME = datetime.datetime.now()
saved_time = datetime.datetime.now()


def write_log(text):
    with open('data/logs/logs.txt', 'a') as logfile:
        logfile.write(f'[{datetime.datetime.now()}] : {text}\n')


class ClickerBot:
    def __init__(self, vk_session, db_sess):
        self.vk_session = vk_session
        self.db_session = db_sess
        self.waiting_for_authorization = False  # –ï—Å–ª–∏ True, —Ç–æ –∂–¥–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏—è —Å –Ω–∏–∫–æ–º –¥–ª—è —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏
        self.keyboard = self.create_keyboard()
        self.modificators_keyboard = self.create_modificator_keyboard()
        self.agreement_keyboard = self.create_agreement_keyboard()
        self.functions_keyboard = self.create_functions_keyboard()
        self.helping_keyboard = self.create_helping_leyboard()
        self.back_keyboard = self.create_back_keyboard()
        self.in_modificators = False
        mods = [i[0] for i in get_modificators(self.db_session)]
        self.ids = [i[1] for i in get_modificators(self.db_session)]
        self.texts = ['–∫–ª–∏–∫ üëÜüèª', '–º–æ–¥–∏—Ñ–∏–∫–∞—Ç–æ—Ä—ã üí≤', '–±–∞–ª–∞–Ω—Å üí∞', 'üîô back', '—Ñ—É–Ω–∫—Ü–∏–∏ ‚öô', '–ø–µ—Ä–µ–¥–∞—á–∞ –≤–∞–ª—é—Ç—ã',
                      '–ø–æ–ª—É—á–∏—Ç—å –∞–Ω–µ–∫–¥–æ—Ç', *mods]
        self.price = None
        self.want_to_buy = False
        self.m_id = 0
        self.in_functions = False
        self.in_exchange = False
        self.accept_exchange = False
        self.in_value_changing = False
        self.nickname_to_exchange = ''
        self.anekdots = all_anekdots()
        self.rofls = []
        self.value_to_exchange = 0
        self.nicknames_list = get_nicknames_list(self.db_session)
        print(self.nicknames_list)

    def accept_message(self, obj):
        uid = obj.message['from_id']
        text_mes = obj.message['text']
        text = text_mes.lower()

        if text_mes.lower() not in self.texts and '‚öô' not in text_mes:
            write_log(f'Resieved message from uid = "{uid}" and text = "{text_mes}"')

        else:
            if text == self.texts[0]:
                write_log(f'User with uid = "{uid}" clicked')
            if text == self.texts[1]:
                write_log(f'User with uid = "{uid}" got modificators list')
            if text == self.texts[2]:
                write_log(f'User with uid = "{uid}" got balance')
            if text == self.texts[4]:
                write_log(f'User with uid = "{uid}" got functions list')
            if text == self.texts[5]:
                write_log(f'User with uid = "{uid}" decided to transfer the coins')

        if self.waiting_for_authorization:
            auth = check_valid_nickname(text_mes, self.db_session, self.texts)
            if auth[0]:
                add_user(uid, text_mes, self.db_session)
                self.nicknames_list += text_mes
                self.reply_to_user('–û—Ç–ª–∏—á–Ω–æ! –ù–∞–ø–∏—à–∏ "—Å—Ç–∞—Ä—Ç" —á—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å!', obj)
                self.waiting_for_authorization = False
            else:
                self.reply_to_user(auth[1], obj)
        else:
            if not check_user(uid, self.db_session):
                self.reply_to_user('–ü—Ä–∏–≤–µ—Ç! –í–∏–∂—É, —Ç—ã –≤–ø–µ—Ä–≤—ã–µ —É –Ω–∞—Å', obj)
                self.reply_to_user(
                    '–ù–∞–ø–∏—à–∏ —Å–≤–æ–π –Ω–∏–∫, –∏ —è —Ç–µ–±—è –∑–∞–ø–æ–º–Ω—é\n'
                    '–í–Ω–∏–º–∞–Ω–∏–µ! –ò–º—è –Ω–µ –¥–æ–ª–∂–Ω–æ –Ω–∞—á–∏–Ω–∞—Ç—å—Å—è –∏–ª–∏ –∑–∞–∫–∞–Ω—á–∏–≤–∞—Ç—å—Å—è –Ω–∞ —Ü–∏—Ñ—Ä—ã –∏–ª–∏ –Ω–µ–¥–æ–ø—É—Å—Ç–∏–º—ã–µ —Å–∏–º–≤–æ–ª—ã!\n',
                    obj)
                self.waiting_for_authorization = True
            else:
                if text == '–ø–æ–º–æ—â—å' and check_user(uid, self.db_session):
                    self.reply_to_user('–ö–Ω–æ–ø–∫–∞ –∫–ª–∏–∫: –ø–æ–ª—É—á–∏—Ç—å –∫–æ–∏–Ω—ã\n'
                                       '–ú–æ–¥–∏—Ñ–∏–∫–∞—Ç–æ—Ä—ã: –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –º–æ–¥–∏—Ñ–∏–∫–∞—Ç–æ—Ä–∞—Ö\n'
                                       '–ë–∞–ª–∞–Ω—Å: –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –≤–∞—à–µ–º –±–∞–ª–∞–Ω—Å–µ\n'
                                       '–î–ª—è –Ω–∞—á–∞–ª–∞ –ø–∏—à–∏/–Ω–∞–∂–∏–º–∞–π "—Å—Ç–∞—Ä—Ç"\n'
                                       '–ï—Å–ª–∏ –±–æ—Ç –Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç - –Ω–∞–ø–∏—à–∏/–Ω–∞–∂–º–∏ "—Ä–µ—Å—Ç–∞—Ä—Ç" –∏ –≤—Å–µ –∑–∞—Ä–∞–±–æ—Ç–∞–µ—Ç!', obj,
                                       self.helping_keyboard)
                if text != '–ø–æ–º–æ—â—å' and text != '—Å—Ç–∞—Ä—Ç' and text != '—Ä–µ—Å—Ç–∞—Ä—Ç' and text not in self.texts and text not \
                        in ['–¥–∞', '–Ω–µ—Ç'] and text_mes not in self.nicknames_list:
                    print(self.texts)
                    self.reply_to_user('–ü–∏—à–∏ –∏–ª–∏ –Ω–∞–∂–∏–º–∞–π "–ü–æ–º–æ—â—å"\n–ï—Å–ª–∏ –±–æ—Ç –∑–∞–≤–∏—Å - –Ω–∞–ø–∏—à–∏ –∏–ª–∏ –Ω–∞–∂–º–∏ "–°—Ç–∞—Ä—Ç"', obj,
                                       self.helping_keyboard)
                if text == '—Å—Ç–∞—Ä—Ç' or text == '—Ä–µ—Å—Ç–∞—Ä—Ç':
                    self.reply_to_user('–£–¥–∞—á–∏!', obj, self.keyboard)
                    self.in_modificators, \
                    self.in_exchange, \
                    self.in_functions = False, False, False
                    print(self.texts)

                elif self.texts[0] == text and not self.in_modificators:
                    user_modificator = get_user_modificator(obj.message['from_id'], self.db_session)
                    rand = random.randint(1, 10) * user_modificator
                    self.reply_to_user(f'+ {rand} –∫–æ–∏–Ω–æ–≤', obj, self.keyboard)
                    add_coins(obj.message['from_id'], rand, self.db_session)
                    write_log(f'User with uid = "{uid}" recieved {rand} coins')

                elif self.texts[1] == text and not self.in_modificators:
                    self.reply_to_user('–ù–∞–∂–∞—Ç–∏–µ –Ω–∞ –º–æ–¥–∏—Ñ–∏–∫–∞—Ç–æ—Ä –≤–µ—Ä–Ω–µ—Ç –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –Ω–µ–º', obj,
                                       self.modificators_keyboard)
                    self.in_modificators = True

                elif self.texts[2] == text and not self.in_modificators:
                    coins = get_balance(obj.message["from_id"], self.db_session)
                    self.reply_to_user(f'–£ –≤–∞—Å {coins} –º–æ–Ω–µ—Ç', obj, self.keyboard)

                elif text == self.texts[3] and self.in_modificators:
                    self.in_modificators = False
                    self.reply_to_user('–í–æ–∑–≤—Ä–∞—â–∞–µ–º—Å—è...', obj, self.keyboard)

                elif text in self.texts[7:] and self.in_modificators:
                    self.m_id = self.texts.index(text) - 6
                    price, multiplier = get_price_and_multiplier_of_modificator(self.m_id, self.db_session)
                    self.reply_to_user(f'–£–≤–µ–ª–∏—á–∏–≤–∞–µ—Ç –≤ {multiplier} —Ä–∞–∑–∞ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ–ª—É—á–∞–µ–º—ã—Ö –∫–æ–∏–Ω–æ–≤.\n'
                                       f'–°—Ç–æ–∏–º–æ—Å—Ç—å: {price}', obj, self.modificators_keyboard)

                    self.want_to_buy = True
                if self.want_to_buy and text not in ['—Å—Ç–∞—Ä—Ç', '–¥–∞', '–Ω–µ—Ç']:
                    self.reply_to_user('–•–æ—á–µ—à—å –ø—Ä–∏–æ–±—Ä–µ—Å—Ç–∏?', obj, self.agreement_keyboard)

                elif self.want_to_buy and text == '–¥–∞' or text == '–Ω–µ—Ç':
                    self.want_to_buy = False
                    op = check_can_be_bought(obj.message['from_id'], self.m_id, self.db_session)
                    if op and text == '–¥–∞':
                        self.reply_to_user('–ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º —Å —É—Å–ø–µ—à–Ω–æ–π –ø–æ–∫—É–ø–∫–æ–π!', obj, self.modificators_keyboard)
                        set_modificator(obj.message['from_id'], self.m_id, self.db_session)
                    elif op is False and text == '–¥–∞':
                        self.reply_to_user('–ù–∞ –≤–∞—à–µ–º –±–∞–ª–∞–Ω—Å–µ –Ω–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å—Ä–µ–¥—Å—Ç–≤ –∏–ª–∏ —É –≤–∞—Å —É–∂–µ –∫—É–ø–ª–µ–Ω '
                                           '–º–æ–¥–∏—Ñ–∏–∫–∞—Ç–æ—Ä —Ä–∞–≤–Ω—ã–π –∏–ª–∏ –ª—É—á—à–µ —ç—Ç–æ–≥–æ.', obj, self.modificators_keyboard)
                    elif text == '–Ω–µ—Ç':
                        self.reply_to_user('–ü—Ä–æ–¥–æ–ª–∂–∞–µ–º...', obj, self.modificators_keyboard)
                    obj.message['text'] = '—Å—Ç–∞—Ä—Ç'


                elif text_mes == '–§—É–Ω–∫—Ü–∏–∏ ‚öô' and not (self.in_modificators or self.in_functions or self.in_exchange):
                    self.in_functions = True
                    print(self.in_functions)
                    self.reply_to_user('–û—Ç–∫—Ä—ã—Ç–æ –º–µ–Ω—é —Ñ—É–Ω–∫—Ü–∏–π', obj, self.functions_keyboard)

                elif self.in_value_changing:
                    if text == self.texts[3]:
                        self.in_exchange, self.in_value_changing = False, False
                    try:
                        if check_value_to_exchange(uid, int(text_mes),
                                                   self.db_session) and not \
                                get_user_nickname_on_uid(uid, self.nickname_to_exchange, self.db_session):
                            self.value_to_exchange = int(text_mes)
                            write_log(
                                f'User with uid = "{uid}" gave to the user with nickname = "{text_mes}" '
                                f'{self.value_to_exchange} coins')
                            self.reply_to_user('–£—Å–ø–µ—à–Ω–æ –ø–µ—Ä–µ–¥–∞–Ω–æ', obj, self.functions_keyboard)
                            do_exchange(self.value_to_exchange, uid, self.nickname_to_exchange, self.db_session)
                            self.in_exchange, self.in_value_changing, self.nickname_to_exchange, \
                            self.value_to_exchange = False, False, '', 0
                        elif get_user_nickname_on_uid(uid, self.nickname_to_exchange, self.db_session):
                            self.reply_to_user("–¢—ã —Å–µ—Ä—å–µ–∑–Ω–æ —Ä–µ—à–∏–ª –ø–µ—Ä–µ–¥–∞—Ç—å –∫–æ–∏–Ω—ã —Å–µ–±–µ? –ù–µ –Ω–∞–¥–æ —Ç–∞–∫", obj,
                                               self.back_keyboard)
                        else:
                            self.reply_to_user('–í–≤–µ–¥–µ–Ω–∞ –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω–∞—è —Å—É–º–º–∞!', obj, self.back_keyboard)
                    except ValueError:
                        self.reply_to_user('–í —Ç–≤–æ–µ–º —Å–æ–æ–±—â–µ–Ω–∏–∏ –ø—Ä–∏—Å—É—Ç—Å–≤—É—é—Ç —Å–∏–º–≤–æ–ª—ã, –æ—Ç–ª–∏—á–Ω—ã–µ –æ—Ç —Ü–∏—Ñ—Ä. –ü–æ–ø—Ä–æ–±—É–π –µ—â–µ —Ä–∞–∑',
                                           obj, self.back_keyboard)

                elif self.in_functions and not self.in_exchange and not self.in_value_changing:
                    if text == self.texts[5]:
                        self.reply_to_user('–û—Ç–∫—Ä—ã—Ç–æ –º–µ–Ω—é –ø–µ—Ä–µ–¥–∞—á–∏\n–ù–∞–ø–∏—à–∏ –Ω–∏–∫ –∏–≥—Ä–æ–∫–∞, –∫–æ—Ç–æ—Ä–æ–º—É —Ö–æ—á–µ—à—å –ø–µ—Ä–µ–¥–∞—Ç—å –∫–æ–∏–Ω—ã',
                                           obj, self.back_keyboard)
                        self.in_exchange = True

                    if text == self.texts[6]:
                        self.reply_to_user(self.get_rofl(), obj, self.functions_keyboard)
                    if text == self.texts[3]:
                        self.reply_to_user('–í–æ–∑–≤—Ä–∞—â–∞–µ–º—Å—è...', obj, self.keyboard)
                        self.in_functions = False
                        print(self.in_functions)

                elif self.in_exchange and not self.in_value_changing:
                    nn = check_user_on_nickname(text_mes, self.db_session)
                    if text == self.texts[3]:
                        self.in_exchange = False
                        self.reply_to_user('–í–æ–∑–≤—Ä–∞—â–∞–µ–º—Å—è...', obj, self.functions_keyboard)
                    elif nn:
                        self.nickname_to_exchange = text_mes
                        self.reply_to_user('–û—Ç–ª–∏—á–Ω–æ, —Ç–µ–ø–µ—Ä—å –≤–≤–µ–¥–∏ —Å—É–º–º—É, –∫–æ—Ç–æ—Ä—É—é —Ö–æ—á–µ—à—å –ø–µ—Ä–µ–¥–∞—Ç—å', obj,
                                           self.back_keyboard)
                        self.in_value_changing = True
                    elif not nn:
                        self.reply_to_user('–ö–∞–∂–µ—Ç—Å—è, —Ç–∞–∫–æ–≥–æ –∏–≥—Ä–æ–∫–∞ –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç. –ü—Ä–æ–≤–µ—Ä—å –ø—Ä–∞–≤–∏–ª—å–Ω–æ—Å—Ç—å –Ω–∞–ø–∏—Å–∞–Ω–∏—è', obj,
                                           self.back_keyboard)

    def reply_to_user(self, text, obj, kboard=None):
        vk = vk_session.get_api()
        vk.messages.send(user_id=obj.message['from_id'],
                         message=text,
                         random_id=random.randint(0, 2 ** 64),
                         keyboard=kboard)

    def get_rofl(self):
        try:
            tmp = []
            if len(self.rofls) == 0:
                for i in self.anekdots:
                    if i != ';':
                        tmp += [i]
                    else:
                        self.rofls += [tmp[:]]
                        tmp.clear()
            rnd = random.choice(self.rofls)
            self.rofls.remove(rnd)
            return '\n'.join(rnd)
        except Exception as e:
            return '–®—É—Ç–∫–∏ –∫–æ–Ω—á–∏–ª–∏—Å—å ;)'

    def create_helping_leyboard(self):
        keyboard = VkKeyboard(one_time=False)
        keyboard.add_button("–°—Ç–∞—Ä—Ç", color=VkKeyboardColor.POSITIVE)
        keyboard.add_line()
        keyboard.add_button("–ü–æ–º–æ—â—å", color=VkKeyboardColor.SECONDARY)
        return keyboard.get_keyboard()

    def create_back_keyboard(self):
        keyboard = vk_api.keyboard.VkKeyboard()
        keyboard.add_button("üîô Back", color=VkKeyboardColor.NEGATIVE)
        keyboard.add_button('–†–µ—Å—Ç–∞—Ä—Ç', color=VkKeyboardColor.SECONDARY)
        return keyboard.get_keyboard()

    def create_keyboard(self):
        keyboard = vk_api.keyboard.VkKeyboard(one_time=False)
        keyboard.add_button("–ö–ª–∏–∫ üëÜüèª", color=VkKeyboardColor.SECONDARY)
        keyboard.add_button("–ú–æ–¥–∏—Ñ–∏–∫–∞—Ç–æ—Ä—ã üí≤", color=VkKeyboardColor.NEGATIVE)
        keyboard.add_line()
        keyboard.add_button("–§—É–Ω–∫—Ü–∏–∏ ‚öô", color=VkKeyboardColor.POSITIVE)
        keyboard.add_button("–ë–∞–ª–∞–Ω—Å üí∞", color=VkKeyboardColor.POSITIVE)
        keyboard.add_button("–†–µ—Å—Ç–∞—Ä—Ç", color=VkKeyboardColor.NEGATIVE)
        return keyboard.get_keyboard()

    def create_modificator_keyboard(self):
        k = 1
        keyboard = VkKeyboard(one_time=False)
        mods = get_modificators(self.db_session)
        for i in range(len(mods)):
            keyboard.add_button(mods[i][0], color=VkKeyboardColor.PRIMARY)
            if k % 3 == 0:
                keyboard.add_line()
            k += 1
        print(k)
        if (k - 1) % 3 != 0:
            keyboard.add_line()
        keyboard.add_button("üîô Back", color=VkKeyboardColor.POSITIVE)
        return keyboard.get_keyboard()

    def create_agreement_keyboard(self):
        keyboard = VkKeyboard(one_time=True)
        keyboard.add_button("–î–∞", color=VkKeyboardColor.POSITIVE)
        keyboard.add_button("–ù–µ—Ç", color=VkKeyboardColor.NEGATIVE)
        return keyboard.get_keyboard()

    def create_functions_keyboard(self):
        keyboard = VkKeyboard()
        keyboard.add_button("–ü–µ—Ä–µ–¥–∞—á–∞ –≤–∞–ª—é—Ç—ã", color=VkKeyboardColor.PRIMARY)
        keyboard.add_button("–ü–æ–ª—É—á–∏—Ç—å –∞–Ω–µ–∫–¥–æ—Ç", color=VkKeyboardColor.SECONDARY)
        keyboard.add_line()
        keyboard.add_button("üîô Back", color=VkKeyboardColor.NEGATIVE)
        return keyboard.get_keyboard()


def set_modificator(uid, mod_id, sess):
    global User, Modificators
    u = sess.query(User).filter_by(uid=uid).first()
    mod = sess.query(Modificators).filter_by(id=mod_id).first()
    u.modificator = mod.id
    u.clicks -= mod.price
    sess.commit()


def add_user(uid, nickname, sess):
    global User
    u = User()
    u.uid = str(uid)
    u.nickname = nickname
    sess.add(u)
    sess.commit()
    write_log(f'Added user with uid = "{uid}" and nickname = "{nickname}"')


def add_coins(uid, coins, sess):
    global User
    save = sess.query(User).filter_by(uid=uid).first()
    save.clicks += coins
    sess.commit()


def get_balance(uid, sess):
    global User
    return (sess.query(User).filter_by(uid=uid).first()).clicks


def get_modificators(sess):
    global Modificators
    mods = sess.query(Modificators).all()
    lst = []
    for mod in mods:
        if mod.id != 0:
            lst += [(mod.name, mod.id)]
    return lst


def get_user_nickname_on_uid(uid, nickname, session: db_session):
    global User
    return (session.query(User).filter_by(uid=uid).first()).nickname == nickname


def get_user_modificator(uid, sess):
    global User
    mod = sess.query(User).filter_by(uid=uid).first()
    modificator = sess.query(Modificators).filter_by(id=mod.modificator).first()
    return modificator.multiplier


def check_can_be_bought(uid, mod_id, sess):
    global User, Modificators
    mod = sess.query(Modificators).filter_by(id=mod_id).first()
    user = sess.query(User).filter_by(uid=uid).first()
    return user.clicks >= mod.price and user.modificator < mod.id


def get_price_and_multiplier_of_modificator(id, sess):
    global Modificators
    mod = sess.query(Modificators).filter_by(id=id).first()
    return mod.price, mod.multiplier


def check_user(uid, db_sess):  # –ø—Ä–æ–≤–µ—Ä—è–µ—Ç –Ω–∞–ª–∏—á–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤ –±–∞–∑–µ
    global User
    users = db_sess.query(User).all()
    for user in users:
        if user.uid == str(uid):
            return True
    return False


def check_valid_nickname(nickname: str, session, texts):
    global User
    tmp = texts + ['false', 'true']
    users = session.query(User).all()
    for text in tmp:
        if nickname in text:
            return [False, '–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, —ç—Ç–æ —Å–ª–æ–≤–æ –∑–∞—Ä–µ–∑–µ—Ä–≤–∏—Ä–æ–≤–∞–Ω–æ –¥–ª—è —Ä–∞–±–æ—Ç—ã –±–æ—Ç–∞. –ü—Ä–∏–¥—É–º–∞–π—Ç–µ –¥—Ä—É–≥–æ–π –Ω–∏–∫']
    for user in users:
        if user.nickname == nickname:
            return [False, '–û—à–∏–±–∫–∞: –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å —Ç–∞–∫–∏–º –∏–º–µ–Ω–µ–º —É–∂–µ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω!']
    for symbol in '''!'1234567890@#$%^&*()_+{}:"?><][';/.,'"-=`~/*\|''':
        if nickname.startswith(symbol):
            return [False, '–û—à–∏–±–∫–∞: –ò–º—è –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è —Å –Ω–µ–¥–æ–ø—É—Å—Ç–∏–º–æ–≥–æ —Å–∏–º–≤–æ–ª–∞!']
        elif nickname.endswith(symbol):
            return [False, '–û—à–∏–±–∫–∞: –ò–º—è –∑–∞–∫–∞–Ω—á–∏–≤–∞–µ—Ç—Å—è –Ω–∞ –Ω–µ–¥–æ–ø—É—Å—Ç–∏–º—ã–π —Å–∏–º–≤–æ–ª!']
    for symb in '''!'^()+{}:"?';/.,'"-=`~/*\|''':
        if symb in nickname:
            return [False, '–û—à–∏–±–∫–∞: –í–Ω—É—Ç—Ä–∏ –∏–º–µ–Ω–∏ –Ω–µ–¥–æ–ø—É—Å—Ç–∏–º—ã–π —Å–∏–º–≤–æ–ª!']
    return [True, '']


def check_user_on_nickname(nickname, session):  # –ø—Ä–æ–≤–µ—Ä—è–µ—Ç –Ω–∞–ª–∏—á–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤ –±–∞–∑–µ –ø–æ –±–¥
    global User
    for user in session.query(User).all():
        if nickname == user.nickname:
            return True
    return False


def get_nicknames_list(session: db_session):
    global User
    res = []
    for i in session.query(User).all():
        res.append(i.nickname)
    return res


def do_exchange(summ, sender_uid, acceptor_nickname, session: db_session):
    global User
    sender_clicks = (session.query(User).filter_by(uid=sender_uid).first()).clicks
    acceptor_clicks = (session.query(User).filter_by(nickname=acceptor_nickname).first()).clicks
    print(f'{sender_clicks} / {acceptor_clicks}')
    session.query(User).filter_by(uid=sender_uid).update({'clicks': int(sender_clicks - summ)})
    session.query(User).filter_by(nickname=acceptor_nickname).update({'clicks': int(acceptor_clicks + summ)})
    print('exchanged')
    session.commit()


def check_value_to_exchange(uid, summ, session):
    global User
    sender = session.query(User).filter_by(uid=uid).first()
    if sender.clicks >= summ:
        return True
    return False


def check_time_to_commit(session, datetime):
    global saved_time, BOT_START_TIME
    step = 1
    current_time = datetime.datetime.now()
    delta = current_time - BOT_START_TIME
    seconds = delta.total_seconds()
    minutes = (seconds % 3600) // 60
    if minutes // step >= 1 and current_time.minute != saved_time.minute:
        print(1)
        session.commit()
        saved_time = current_time
        write_log('Database changes commited')


def all_anekdots():
    with open('data/jokes/anekdots.txt', 'r', encoding='utf-8') as f:
        return list(map(str.strip, f.readlines()))


def main(vk_session, session, bot, datetime):
    longpoll = VkBotLongPoll(vk_session, group_id='212227596')

    for event in longpoll.listen():
        check_time_to_commit(session, datetime)

        if event.type == VkBotEventType.MESSAGE_NEW:
            vk = vk_session.get_api()
            bot.accept_message(event.obj)
            print('–°–æ–æ–±—â–µ–Ω–∏–µ', event.obj.message['text'])


if __name__ == '__main__':
    write_log('Program started')
    db_session.global_init('data/db/clicker_db.sqlite')
    write_log('Database initialized')
    session = db_session.create_session()
    write_log('Database session created')
    vk_session = vk_api.VkApi(token=TOKEN)
    write_log(f'VK group session created with TOKEN = "{TOKEN}"')
    bot = ClickerBot(vk_session, session)
    main(vk_session, session, bot, datetime)
